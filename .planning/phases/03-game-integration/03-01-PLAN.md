---
phase: 03-game-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gsnake-web/components/Cell.svelte
  - gsnake-web/components/SpriteLoader.svelte
autonomous: true

must_haves:
  truths:
    - "Hazard cells (Spike) render with partial transparency so background tile hints through"
    - "Snake cells (SnakeHead, SnakeBody) render fully opaque, visually dominant over any tile"
    - "SpriteLoader cleans up inlined SVG content when component is destroyed"
    - "All 68 existing tests still pass after changes"
  artifacts:
    - path: "gsnake-web/components/Cell.svelte"
      provides: "Per-CellType opacity mapping for visual layering"
      contains: "getOpacity"
    - path: "gsnake-web/components/SpriteLoader.svelte"
      provides: "onDestroy cleanup that removes inlined SVG from DOM"
      contains: "onDestroy"
  key_links:
    - from: "gsnake-web/components/Cell.svelte"
      to: "sprites.svg symbols"
      via: "SVG use href with CSS opacity style"
      pattern: "opacity.*getOpacity"
    - from: "gsnake-web/components/SpriteLoader.svelte"
      to: "DOM"
      via: "onDestroy removing inlined sprite content"
      pattern: "onDestroy"
---

<objective>
Add per-CellType CSS opacity to Cell.svelte for visual layering depth, and add onDestroy cleanup to SpriteLoader.svelte to prevent memory leaks when switching levels or unmounting.

Purpose: Success criteria #2 requires transparency support for object layering. The game engine stores one CellType per cell (no multi-object stacking), so "layering" means giving hazard/background objects partial transparency to create visual depth — spikes look semi-transparent suggesting danger beneath, while snake and food remain fully opaque. Success criteria #4 requires no memory leaks, which means SpriteLoader must clean up its inlined SVG content on destroy.

Output: Modified Cell.svelte with opacity mapping, modified SpriteLoader.svelte with onDestroy cleanup.
</objective>

<execution_context>
@/home/nntin/.claude/get-shit-done/workflows/execute-plan.md
@/home/nntin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-game-integration/03-RESEARCH.md
@.planning/phases/02-rendering-infrastructure/02-01-SUMMARY.md
@gsnake-web/components/Cell.svelte
@gsnake-web/components/SpriteLoader.svelte
@gsnake-web/types/models.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-CellType opacity mapping to Cell.svelte and onDestroy cleanup to SpriteLoader.svelte</name>
  <files>gsnake-web/components/Cell.svelte, gsnake-web/components/SpriteLoader.svelte</files>
  <action>
**Cell.svelte changes:**

Add a `getOpacity(t: CellType): number` function that returns opacity values based on cell type. Apply the opacity as an inline CSS style on the `<svg>` element.

Opacity mapping rationale (visual layering depth):
- `Empty`: 1.0 (neutral background, no transparency needed)
- `SnakeHead`: 1.0 (player character, always fully visible)
- `SnakeBody`: 1.0 (player character, always fully visible)
- `Food`: 1.0 (critical gameplay object, must be fully visible)
- `FloatingFood`: 1.0 (critical gameplay object)
- `FallingFood`: 1.0 (maps to Food symbol, critical)
- `Obstacle`: 0.9 (slight transparency to suggest it's part of the environment, not a foreground object)
- `Exit`: 1.0 (critical navigation target)
- `Stone`: 0.85 (environmental object, subtle transparency for depth)
- `Spike`: 0.8 (hazard - more transparent to visually suggest danger/depth beneath; per success criteria #2 this is the key transparency case)

Add a reactive declaration: `$: opacity = getOpacity(type);`

Apply to the svg element: `<svg class="cell" viewBox="0 0 32 32" style="opacity: {opacity}">`

Do NOT use svelte:options immutable — not needed for primitive string props.

**SpriteLoader.svelte changes:**

Add `onDestroy` import from 'svelte' alongside existing `onMount`.

Create a variable to track the container element. When spriteContent is rendered via `{@html}`, Svelte handles the DOM insertion. To clean up, set `spriteContent = ""` in onDestroy, which will cause the `{#if}` block to remove the DOM content.

Actually, Svelte's `{#if}` block already removes DOM when the condition becomes false. And when the component is destroyed, Svelte removes all its DOM. So the `{@html}` content IS cleaned up automatically on destroy.

The real risk is if SpriteLoader is mounted/unmounted multiple times (e.g., level switching recreates App). Since App.svelte is the root and SpriteLoader is a direct child, it only mounts once. However, for defensive correctness:

1. Import `onDestroy` from 'svelte'
2. In `onDestroy`, set `spriteContent = ""` to explicitly clear the fetched string from memory
3. This ensures the potentially large SVG string is garbage-collected promptly

This is a small defensive change that costs nothing and satisfies INTEG-06.
  </action>
  <verify>
Run `cd gsnake-web && npm test -- --run` — all 68 tests must pass.

Verify Cell.svelte contains `getOpacity` function with opacity values for all CellType values.

Verify SpriteLoader.svelte contains `onDestroy` import and cleanup logic.

Run `cd gsnake-web && npx tsc --noEmit` to verify TypeScript compilation (no type errors).
  </verify>
  <done>
Cell.svelte applies per-CellType opacity via inline style. Spike renders at 0.8 opacity, Stone at 0.85, Obstacle at 0.9. All other types render at 1.0 (fully opaque). SpriteLoader.svelte has onDestroy cleanup that clears spriteContent. All 68 tests pass. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `cd gsnake-web && npm test -- --run` — 68 tests pass
2. `cd gsnake-web && npx tsc --noEmit` — no type errors
3. Cell.svelte has `getOpacity` function returning different values for Spike (0.8), Stone (0.85), Obstacle (0.9), and 1.0 for all others
4. SpriteLoader.svelte imports `onDestroy` and clears `spriteContent` on destroy
</verification>

<success_criteria>
- Cell.svelte renders SVG elements with per-CellType opacity values applied as inline CSS
- SpriteLoader.svelte has defensive onDestroy cleanup
- All existing tests continue to pass
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-integration/03-01-SUMMARY.md`
</output>
