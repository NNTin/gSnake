# Folder Structure Code Review

## Scope
Code folder structure only (non-markdown). Review focuses on repository layout, boundaries between subsystems, and risks tied to directory organization.

## Findings
### High
- Build artifacts and vendor dependencies are present in the repo, which bloats history and risks stale outputs: `node_modules/`, `gsnake-web/node_modules/`, `gsnake-core/target/`, `gsnake-web/dist/`, `test-results/`.
- Submodule intent is unclear vs. nested repos: `gsnake-web` is listed as a submodule but contains a full `.git/` directory, which will confuse tooling and make root-level Git operations inconsistent.

### Medium
- `gsnake-python` is declared as a submodule but only contains a `.git` pointer file and no visible code; this breaks local builds and makes the layout look incomplete without a dedicated bootstrap step.
- Duplicated toolchain config at root and inside `gsnake-core/` (`rust-toolchain.toml`, `rustfmt.toml`) creates ambiguity about which config is authoritative for contributors and CI.
- Frontend entry points are split between root and component folders (`gsnake-web/App.svelte` and `gsnake-web/components/App.svelte`) with an empty `gsnake-web/index.tsx`, which makes the app’s true entry harder to locate and maintain.

### Low
- The Rust core is nested as `gsnake-core/engine/core` while bindings live in `gsnake-core/engine/bindings/{cli,wasm}`; this is workable but the deep nesting adds path noise and slows discovery of crate boundaries.
- Shared data lives in `gsnake-core/engine/core/data/levels.json`, but there’s no obvious adjacent asset or schema folder, which makes it harder to find or validate game content conventions.
